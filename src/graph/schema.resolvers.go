package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"api/domain/entities"
	appErrors "api/domain/errors"
	"api/graph/generated"
	"api/graph/model"
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*entities.LoginResponse, error) {
	loginRequest := &entities.LoginRequest{
		Email:    input.Email,
		Password: input.Password,
	}

	return r.AuthService.Login(ctx, loginRequest)
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*entities.LoginResponse, error) {
	return r.AuthService.RefreshToken(ctx, refreshToken)
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// O logout é geralmente feito no client-side removendo o token
	// Aqui podemos implementar blacklist de tokens se necessário
	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*entities.User, error) {
	hashedPassword, err := r.AuthService.HashPassword(input.Password)
	if err != nil {
		return nil, appErrors.ErrInternalServer
	}

	active := true
	if input.Active != nil {
		active = *input.Active
	}

	user := &entities.User{
		Username: input.Username,
		Email:    input.Email,
		Password: hashedPassword,
		Role:     entities.UserRole(input.Role),
		Active:   active,
	}

	err = r.UserRepo.Create(ctx, user)
	if err != nil {
		errStr := fmt.Sprintf("%v", err)
		if strings.Contains(errStr, "duplicate key") {
			if strings.Contains(errStr, "email") {
				return nil, appErrors.ErrEmailExists
			}
			if strings.Contains(errStr, "username") {
				return nil, appErrors.ErrUsernameExists
			}
		}
		return nil, appErrors.ErrInternalServer
	}

	// Remove password from response
	user.Password = ""
	return user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*entities.User, error) {
	user, err := r.UserRepo.GetByID(ctx, input.ID)
	if err != nil {
		return nil, appErrors.NotFoundError("Usuário")
	}

	if input.Username != nil {
		user.Username = *input.Username
	}
	if input.Email != nil {
		user.Email = *input.Email
	}
	if input.Role != nil {
		user.Role = entities.UserRole(*input.Role)
	}
	if input.Active != nil {
		user.Active = *input.Active
	}

	err = r.UserRepo.Update(ctx, user)
	if err != nil {
		errStr := fmt.Sprintf("%v", err)
		if strings.Contains(errStr, "duplicate key") {
			if strings.Contains(errStr, "email") {
				return nil, appErrors.ErrEmailExists
			}
			if strings.Contains(errStr, "username") {
				return nil, appErrors.ErrUsernameExists
			}
		}
		return nil, appErrors.ErrInternalServer
	}

	// Remove password from response
	user.Password = ""
	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	err := r.UserRepo.Delete(ctx, id)
	if err != nil {
		return false, appErrors.NotFoundError("Usuário")
	}
	return true, nil
}

// ChangePassword is the resolver for the changePassword field.
func (r *mutationResolver) ChangePassword(ctx context.Context, input model.ChangePasswordInput) (bool, error) {
	// Se userID não foi fornecido, usar o usuário logado
	userID := input.UserID
	if userID == nil {
		// Pegar o usuário do contexto (implementar middleware de auth)
		return false, fmt.Errorf("authentication required")
	}

	user, err := r.UserRepo.GetByID(ctx, *userID)
	if err != nil {
		return false, fmt.Errorf("user not found: %w", err)
	}

	// Se está alterando própria senha, verificar senha atual
	if input.OldPassword != nil {
		if !r.AuthService.VerifyPassword(user.Password, *input.OldPassword) {
			return false, fmt.Errorf("invalid current password")
		}
	}

	hashedPassword, err := r.AuthService.HashPassword(input.NewPassword)
	if err != nil {
		return false, fmt.Errorf("failed to hash password: %w", err)
	}

	user.Password = hashedPassword
	err = r.UserRepo.Update(ctx, user)
	if err != nil {
		return false, fmt.Errorf("failed to update password: %w", err)
	}

	return true, nil
}

// CreateTower is the resolver for the createTower field.
func (r *mutationResolver) CreateTower(ctx context.Context, input model.CreateTowerInput) (*entities.Tower, error) {
	tower := &entities.Tower{
		Name:        input.Name,
		Description: input.Description,
	}

	err := r.TowerRepo.Create(ctx, tower)
	if err != nil {
		return nil, err
	}

	return tower, nil
}

// UpdateTower is the resolver for the updateTower field.
func (r *mutationResolver) UpdateTower(ctx context.Context, input model.UpdateTowerInput) (*entities.Tower, error) {
	tower, err := r.TowerRepo.GetByID(ctx, input.ID)
	if err != nil {
		return nil, err
	}

	if input.Name != nil {
		tower.Name = *input.Name
	}
	if input.Description != nil {
		tower.Description = input.Description
	}

	err = r.TowerRepo.Update(ctx, tower)
	if err != nil {
		return nil, err
	}

	return tower, nil
}

// DeleteTower is the resolver for the deleteTower field.
func (r *mutationResolver) DeleteTower(ctx context.Context, id string) (bool, error) {
	err := r.TowerRepo.Delete(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateFloor is the resolver for the createFloor field.
func (r *mutationResolver) CreateFloor(ctx context.Context, input model.CreateFloorInput) (*entities.Floor, error) {
	floor := &entities.Floor{
		TowerID: input.TowerID,
		Number:  input.Number,
	}

	err := r.FloorRepo.Create(ctx, floor)
	if err != nil {
		return nil, err
	}

	return floor, nil
}

// UpdateFloor is the resolver for the updateFloor field.
func (r *mutationResolver) UpdateFloor(ctx context.Context, input model.UpdateFloorInput) (*entities.Floor, error) {
	floor, err := r.FloorRepo.GetByID(ctx, input.ID)
	if err != nil {
		return nil, err
	}

	if input.Number != nil {
		floor.Number = *input.Number
	}

	err = r.FloorRepo.Update(ctx, floor)
	if err != nil {
		return nil, err
	}

	return floor, nil
}

// DeleteFloor is the resolver for the deleteFloor field.
func (r *mutationResolver) DeleteFloor(ctx context.Context, id string) (bool, error) {
	err := r.FloorRepo.Delete(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// CreateApartment is the resolver for the createApartment field.
func (r *mutationResolver) CreateApartment(ctx context.Context, input model.CreateApartmentInput) (*entities.Apartment, error) {
	available := true
	if input.Available != nil {
		available = *input.Available
	}

	status := entities.ApartmentStatusAvailable
	if input.Status != nil {
		status = entities.ApartmentStatus(*input.Status)
	}

	apartment := &entities.Apartment{
		FloorID:       input.FloorID,
		Number:        input.Number,
		Area:          input.Area,
		Suites:        input.Suites,
		Bedrooms:      input.Bedrooms,
		ParkingSpots:  input.ParkingSpots,
		Status:        status,
		SolarPosition: input.SolarPosition,
		Price:         input.Price,
		Available:     available,
	}

	err := r.ApartmentRepo.Create(ctx, apartment)
	if err != nil {
		return nil, err
	}

	return apartment, nil
}

// UpdateApartment is the resolver for the updateApartment field.
func (r *mutationResolver) UpdateApartment(ctx context.Context, input model.UpdateApartmentInput) (*entities.Apartment, error) {
	apartment, err := r.ApartmentRepo.GetByID(ctx, input.ID)
	if err != nil {
		return nil, err
	}

	if input.Number != nil {
		apartment.Number = *input.Number
	}
	if input.Area != nil {
		apartment.Area = input.Area
	}
	if input.Suites != nil {
		apartment.Suites = input.Suites
	}
	if input.Bedrooms != nil {
		apartment.Bedrooms = input.Bedrooms
	}
	if input.ParkingSpots != nil {
		apartment.ParkingSpots = input.ParkingSpots
	}
	if input.Status != nil {
		apartment.Status = entities.ApartmentStatus(*input.Status)
	}
	if input.SolarPosition != nil {
		apartment.SolarPosition = input.SolarPosition
	}
	if input.Price != nil {
		apartment.Price = input.Price
	}
	if input.Available != nil {
		apartment.Available = *input.Available
	}

	err = r.ApartmentRepo.Update(ctx, apartment)
	if err != nil {
		return nil, err
	}

	return apartment, nil
}

// DeleteApartment is the resolver for the deleteApartment field.
func (r *mutationResolver) DeleteApartment(ctx context.Context, id string) (bool, error) {
	err := r.ApartmentRepo.Delete(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// AddApartmentImage is the resolver for the addApartmentImage field.
func (r *mutationResolver) AddApartmentImage(ctx context.Context, apartmentID string, imageURL string, description *string) (*entities.ApartmentImage, error) {
	image := &entities.ApartmentImage{
		ApartmentID: apartmentID,
		ImageURL:    imageURL,
		Description: description,
		Order:       0,
	}
	if err := r.ApartmentImageRepo.Create(ctx, image); err != nil {
		return nil, err
	}
	return image, nil
}

// RemoveApartmentImage is the resolver for the removeApartmentImage field.
func (r *mutationResolver) RemoveApartmentImage(ctx context.Context, imageID string) (bool, error) {
	return r.ApartmentImageRepo.Delete(ctx, imageID) == nil, nil
}

// ReorderApartmentImages is the resolver for the reorderApartmentImages field.
func (r *mutationResolver) ReorderApartmentImages(ctx context.Context, apartmentID string, imageIds []string) ([]*entities.ApartmentImage, error) {
	if err := r.ApartmentImageRepo.ReorderImages(ctx, apartmentID, imageIds); err != nil {
		return nil, err
	}
	return r.ApartmentImageRepo.GetByApartmentID(ctx, apartmentID)
}

// CreateGalleryImage is the resolver for the createGalleryImage field.
func (r *mutationResolver) CreateGalleryImage(ctx context.Context, input model.CreateGalleryImageInput) (*entities.GalleryImage, error) {
	displayOrder := 0
	if input.DisplayOrder != nil {
		displayOrder = *input.DisplayOrder
	}

	gallery := &entities.GalleryImage{
		Route:        input.Route,
		Title:        input.Title,
		Description:  input.Description,
		DisplayOrder: displayOrder,
	}

	err := r.GalleryRepo.Create(ctx, gallery)
	if err != nil {
		return nil, err
	}

	return gallery, nil
}

// UpdateGalleryImage is the resolver for the updateGalleryImage field.
func (r *mutationResolver) UpdateGalleryImage(ctx context.Context, input model.UpdateGalleryImageInput) (*entities.GalleryImage, error) {
	gallery, err := r.GalleryRepo.GetByID(ctx, input.ID)
	if err != nil {
		return nil, err
	}

	if input.Title != nil {
		gallery.Title = input.Title
	}
	if input.Description != nil {
		gallery.Description = input.Description
	}
	if input.DisplayOrder != nil {
		gallery.DisplayOrder = *input.DisplayOrder
	}

	err = r.GalleryRepo.Update(ctx, gallery)
	if err != nil {
		return nil, err
	}

	return gallery, nil
}

// DeleteGalleryImage is the resolver for the deleteGalleryImage field.
func (r *mutationResolver) DeleteGalleryImage(ctx context.Context, id string) (bool, error) {
	err := r.GalleryRepo.Delete(ctx, id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// ReorderGalleryImages is the resolver for the reorderGalleryImages field.
func (r *mutationResolver) ReorderGalleryImages(ctx context.Context, route string, imageIds []string) ([]*entities.GalleryImage, error) {
	if err := r.GalleryRepo.ReorderImages(ctx, route, imageIds); err != nil {
		return nil, err
	}
	return r.GalleryRepo.GetByRoute(ctx, route)
}

// CreateImagePin is the resolver for the createImagePin field.
func (r *mutationResolver) CreateImagePin(ctx context.Context, input model.CreateImagePinInput) (*entities.ImagePin, error) {
	pin := &entities.ImagePin{
		GalleryImageID: input.GalleryImageID,
		XCoord:         input.XCoord,
		YCoord:         input.YCoord,
		Title:          input.Title,
		Description:    input.Description,
		ApartmentID:    input.ApartmentID,
		LinkURL:        input.LinkURL,
	}

	if err := r.ImagePinRepo.Create(ctx, pin); err != nil {
		return nil, err
	}
	return pin, nil
}

// UpdateImagePin is the resolver for the updateImagePin field.
func (r *mutationResolver) UpdateImagePin(ctx context.Context, input model.UpdateImagePinInput) (*entities.ImagePin, error) {
	// Get existing pin
	pin, err := r.ImagePinRepo.GetByID(ctx, input.ID)
	if err != nil {
		return nil, err
	}

	// Update fields if provided
	if input.XCoord != nil {
		pin.XCoord = *input.XCoord
	}
	if input.YCoord != nil {
		pin.YCoord = *input.YCoord
	}
	if input.Title != nil {
		pin.Title = input.Title
	}
	if input.Description != nil {
		pin.Description = input.Description
	}
	if input.ApartmentID != nil {
		pin.ApartmentID = input.ApartmentID
	}
	if input.LinkURL != nil {
		pin.LinkURL = input.LinkURL
	}

	if err := r.ImagePinRepo.Update(ctx, pin); err != nil {
		return nil, err
	}
	return pin, nil
}

// DeleteImagePin is the resolver for the deleteImagePin field.
func (r *mutationResolver) DeleteImagePin(ctx context.Context, id string) (bool, error) {
	return r.ImagePinRepo.Delete(ctx, id) == nil, nil
}

// UpdateAppConfig is the resolver for the updateAppConfig field.
func (r *mutationResolver) UpdateAppConfig(ctx context.Context, logoURL *string, apiBaseURL *string, cacheControlMaxAge *int) (*entities.AppConfig, error) {
	// Get current config
	config, err := r.AppConfigRepo.Get(ctx)
	if err != nil {
		return nil, err
	}

	// Update fields if provided
	if logoURL != nil {
		config.LogoURL = logoURL
	}
	if apiBaseURL != nil {
		config.APIBaseURL = *apiBaseURL
	}
	if cacheControlMaxAge != nil {
		config.CacheControlMaxAge = *cacheControlMaxAge
	}

	if err := r.AppConfigRepo.Update(ctx, config); err != nil {
		return nil, err
	}
	return config, nil
}

// GetSignedUploadURL is the resolver for the getSignedUploadUrl field.
func (r *mutationResolver) GetSignedUploadURL(ctx context.Context, input model.SignedUploadURLInput) (*model.SignedUploadURLResponse, error) {
	serviceInput := &entities.SignedUploadURLInput{
		FileName:    input.FileName,
		FileType:    input.FileType,
		ContentType: input.ContentType,
		RouteID:     input.RouteID,
		Context:     convertFileContext(input.Context),
	}
	
	response, err := r.FileService.GetSignedUploadURL(ctx, serviceInput)
	if err != nil {
		return nil, err
	}
	
	return &model.SignedUploadURLResponse{
		UploadURL: response.UploadURL,
		MinioPath: response.MinioPath,
		ExpiresAt: response.ExpiresAt.Format("2006-01-02T15:04:05Z07:00"),
		FileID:    response.FileID,
	}, nil
}

// ConfirmFileUpload is the resolver for the confirmFileUpload field.
func (r *mutationResolver) ConfirmFileUpload(ctx context.Context, input model.ConfirmFileUploadInput) (*model.ConfirmFileUploadResponse, error) {
	serviceInput := &entities.ConfirmFileUploadInput{
		FileID:           input.FileID,
		MinioPath:        input.MinioPath,
		RouteID:          input.RouteID,
		OriginalFileName: input.OriginalFileName,
		FileSize:         input.FileSize,
		Checksum:         input.Checksum,
		Context:          convertFileContext(input.Context),
	}
	
	response, err := r.FileService.ConfirmFileUpload(ctx, serviceInput)
	if err != nil {
		return nil, err
	}
	
	var fileMetadata *model.FileMetadataExtended
	if response.FileMetadata != nil {
		var metadataStr *string
		if response.FileMetadata.Metadata != nil {
			metadata, _ := json.Marshal(response.FileMetadata.Metadata)
			metadataJSON := string(metadata)
			metadataStr = &metadataJSON
		}
		
		fileMetadata = &model.FileMetadataExtended{
			ID:           response.FileMetadata.ID,
			URL:          response.FileMetadata.URL,
			DownloadURL:  &response.FileMetadata.DownloadURL,
			ThumbnailURL: &response.FileMetadata.ThumbnailURL,
			Metadata:     metadataStr,
		}
	}
	
	return &model.ConfirmFileUploadResponse{
		Success:      response.Success,
		FileMetadata: fileMetadata,
	}, nil
}

// RequestFullSync is the resolver for the requestFullSync field.
func (r *mutationResolver) RequestFullSync(ctx context.Context, input model.FullSyncInput) (*model.FullSyncResponse, error) {
	// TODO: Implementar lógica de criação de ZIP
	syncID := fmt.Sprintf("sync_%d", time.Now().Unix())
	expiresAt := time.Now().Add(24 * time.Hour)
	
	return &model.FullSyncResponse{
		ZipURL:        fmt.Sprintf("https://storage.example.com/syncs/%s.zip", syncID),
		ExpiresAt:     expiresAt.Format("2006-01-02T15:04:05Z07:00"),
		TotalFiles:    10, // stub
		EstimatedSize: 1024000, // 1MB stub
		SyncID:        syncID,
	}, nil
}

// UpdateSyncMetadata is the resolver for the updateSyncMetadata field.
func (r *mutationResolver) UpdateSyncMetadata(ctx context.Context, input model.SyncMetadataInput) (*model.UpdateSyncMetadataResponse, error) {
	serverTimestamp := time.Now().Format("2006-01-02T15:04:05Z07:00")
	return &model.UpdateSyncMetadataResponse{
		Success:         true,
		ServerTimestamp: &serverTimestamp,
	}, nil
}

// UpdateRouteBusinessData is the resolver for the updateRouteBusinessData field.
func (r *mutationResolver) UpdateRouteBusinessData(ctx context.Context, input model.RouteBusinessDataInput) (*model.UpdateRouteBusinessDataResponse, error) {
	lastModified := time.Now().Format("2006-01-02T15:04:05Z07:00")
	return &model.UpdateRouteBusinessDataResponse{
		Success:      true,
		LastModified: &lastModified,
		Conflicts:    []*model.ConflictData{},
	}, nil
}

// CreateMenu is the resolver for the createMenu field.
func (r *mutationResolver) CreateMenu(ctx context.Context, input model.CreateMenuInput) (*model.MenuResponse, error) {
	return &model.MenuResponse{
		Menu: &model.Menu{
			ID:     fmt.Sprintf("menu_%d", time.Now().Unix()),
			Title:  input.Title,
			Type:   input.Type,
			Route:  input.Route,
			Order:  input.Order,
			IsActive: true,
		},
	}, nil
}

// UpdateMenu is the resolver for the updateMenu field.
func (r *mutationResolver) UpdateMenu(ctx context.Context, input model.UpdateMenuInput) (*model.MenuResponse, error) {
	return &model.MenuResponse{
		Menu: &model.Menu{
			ID:     input.MenuID,
			Title:  *input.Title,
			Type:   model.MenuTypeMain, // stub
			Route:  *input.Route,
			Order:  *input.Order,
			IsActive: *input.IsActive,
		},
	}, nil
}

// DeleteMenu is the resolver for the deleteMenu field.
func (r *mutationResolver) DeleteMenu(ctx context.Context, menuID string) (*model.DeleteResponse, error) {
	return &model.DeleteResponse{
		Success: true,
	}, nil
}

// CreateImageCarousel is the resolver for the createImageCarousel field.
func (r *mutationResolver) CreateImageCarousel(ctx context.Context, input model.CreateImageCarouselInput) (*model.ImageCarouselResponse, error) {
	return &model.ImageCarouselResponse{
		Carousel: &model.ImageCarousel{
			ID:          fmt.Sprintf("carousel_%d", time.Now().Unix()),
			Title:       input.Title,
			Route:       input.Route,
			Items:       []*model.CarouselItem{},
			CreatedAt:   time.Now().Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt:   time.Now().Format("2006-01-02T15:04:05Z07:00"),
		},
	}, nil
}

// UpdateImageCarousel is the resolver for the updateImageCarousel field.
func (r *mutationResolver) UpdateImageCarousel(ctx context.Context, input model.UpdateImageCarouselInput) (*model.ImageCarouselResponse, error) {
	return &model.ImageCarouselResponse{
		Carousel: &model.ImageCarousel{
			ID:    input.CarouselID,
			Title: *input.Title,
			Route: "example-route",
			Items: []*model.CarouselItem{},
			CreatedAt: time.Now().AddDate(0, -1, 0).Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt: time.Now().Format("2006-01-02T15:04:05Z07:00"),
		},
	}, nil
}

// AddCarouselItem is the resolver for the addCarouselItem field.
func (r *mutationResolver) AddCarouselItem(ctx context.Context, input model.AddCarouselItemInput) (*model.CarouselItemResponse, error) {
	return &model.CarouselItemResponse{
		Item: &model.CarouselItem{
			ID:    fmt.Sprintf("item_%d", time.Now().Unix()),
			Type:  input.Type,
			URL:   *input.URL,
			Order: input.Order,
		},
	}, nil
}

// RemoveCarouselItem is the resolver for the removeCarouselItem field.
func (r *mutationResolver) RemoveCarouselItem(ctx context.Context, carouselID string, itemID string) (*model.DeleteResponse, error) {
	return &model.DeleteResponse{
		Success: true,
	}, nil
}

// ReorderCarouselItems is the resolver for the reorderCarouselItems field.
func (r *mutationResolver) ReorderCarouselItems(ctx context.Context, input model.ReorderCarouselItemsInput) (*model.ReorderResponse, error) {
	return &model.ReorderResponse{
		Success: true,
		Items:   []*model.CarouselItem{},
	}, nil
}

// CreateFloorPlan is the resolver for the createFloorPlan field.
func (r *mutationResolver) CreateFloorPlan(ctx context.Context, input model.CreateFloorPlanInput) (*model.FloorPlanResponse, error) {
	return &model.FloorPlanResponse{
		FloorPlan: &model.FloorPlan{
			ID:          fmt.Sprintf("floorplan_%d", time.Now().Unix()),
			Title:       input.Title,
			Route:       input.Route,
			FloorNumber: input.FloorNumber,
			Floors:      []*model.FloorPlanFloor{},
			Markers:     []*model.FloorMarker{},
		},
	}, nil
}

// UpdateFloorPlan is the resolver for the updateFloorPlan field.
func (r *mutationResolver) UpdateFloorPlan(ctx context.Context, input model.UpdateFloorPlanInput) (*model.FloorPlanResponse, error) {
	return &model.FloorPlanResponse{
		FloorPlan: &model.FloorPlan{
			ID:    input.FloorPlanID,
			Title: *input.Title,
			Route: "example-route",
			Floors: []*model.FloorPlanFloor{},
			Markers: []*model.FloorMarker{},
		},
	}, nil
}

// AddFloor is the resolver for the addFloor field.
func (r *mutationResolver) AddFloor(ctx context.Context, input model.AddFloorInput) (*model.FloorResponse, error) {
	return &model.FloorResponse{
		Floor: &model.FloorPlanFloor{
			ID:         fmt.Sprintf("floor_%d", time.Now().Unix()),
			Number:     input.Number,
			Name:       input.Name,
			Markers:    []*model.FloorMarker{},
			Apartments: []*model.FloorApartment{},
		},
	}, nil
}

// AddFloorMarker is the resolver for the addFloorMarker field.
func (r *mutationResolver) AddFloorMarker(ctx context.Context, input model.AddFloorMarkerInput) (*model.MarkerResponse, error) {
	return &model.MarkerResponse{
		Marker: &model.FloorMarker{
			ID:   fmt.Sprintf("marker_%d", time.Now().Unix()),
			Type: input.Type,
			Position: &model.Position{
				X: input.Position.X,
				Y: input.Position.Y,
			},
			ApartmentID: input.ApartmentID,
		},
	}, nil
}

// UpdateApartmentStatus is the resolver for the updateApartmentStatus field.
func (r *mutationResolver) UpdateApartmentStatus(ctx context.Context, input model.UpdateApartmentStatusInput) (*model.ApartmentStatusResponse, error) {
	lastStatusChange := time.Now().Format("2006-01-02T15:04:05Z07:00")
	return &model.ApartmentStatusResponse{
		Apartment: &model.FloorApartment{
			ID:               input.ApartmentID,
			Number:           "101", // stub
			Status:           input.Status,
			LastStatusChange: &lastStatusChange,
		},
	}, nil
}

// CreatePinMap is the resolver for the createPinMap field.
func (r *mutationResolver) CreatePinMap(ctx context.Context, input model.CreatePinMapInput) (*model.PinMapResponse, error) {
	return &model.PinMapResponse{
		PinMap: &model.PinMap{
			ID:    fmt.Sprintf("pinmap_%d", time.Now().Unix()),
			Title: input.Title,
			Route: input.Route,
			Pins:  []*model.Pin{},
		},
	}, nil
}

// UpdatePinMap is the resolver for the updatePinMap field.
func (r *mutationResolver) UpdatePinMap(ctx context.Context, input model.UpdatePinMapInput) (*model.PinMapResponse, error) {
	return &model.PinMapResponse{
		PinMap: &model.PinMap{
			ID:    input.PinMapID,
			Title: *input.Title,
			Route: "example-route",
			Pins:  []*model.Pin{},
		},
	}, nil
}

// AddPin is the resolver for the addPin field.
func (r *mutationResolver) AddPin(ctx context.Context, input model.AddPinInput) (*model.PinResponse, error) {
	return &model.PinResponse{
		Pin: &model.Pin{
			ID:    fmt.Sprintf("pin_%d", time.Now().Unix()),
			Type:  input.Type,
			Label: input.Label,
			Position: &model.Position{
				X: input.Position.X,
				Y: input.Position.Y,
			},
			Annotations: []*model.PinAnnotation{},
		},
	}, nil
}

// UpdatePin is the resolver for the updatePin field.
func (r *mutationResolver) UpdatePin(ctx context.Context, input model.UpdatePinInput) (*model.PinResponse, error) {
	return &model.PinResponse{
		Pin: &model.Pin{
			ID:    input.PinID,
			Type:  model.PinTypeInfo, // stub
			Label: *input.Label,
			Position: &model.Position{
				X: input.Position.X,
				Y: input.Position.Y,
			},
			Annotations: []*model.PinAnnotation{},
		},
	}, nil
}

// RemovePin is the resolver for the removePin field.
func (r *mutationResolver) RemovePin(ctx context.Context, pinMapID string, pinID string) (*model.DeleteResponse, error) {
	return &model.DeleteResponse{
		Success: true,
	}, nil
}

// AddPinAnnotation is the resolver for the addPinAnnotation field.
func (r *mutationResolver) AddPinAnnotation(ctx context.Context, input model.AddPinAnnotationInput) (*model.AnnotationResponse, error) {
	createdAt := time.Now().Format("2006-01-02T15:04:05Z07:00")
	return &model.AnnotationResponse{
		Annotation: &model.PinAnnotation{
			ID:        fmt.Sprintf("annotation_%d", time.Now().Unix()),
			Type:      input.Type,
			Content:   input.Content,
			CreatedAt: createdAt,
			Author:    "system", // stub
		},
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*entities.User, error) {
	// Extrair usuário do contexto
	user, ok := ctx.Value("user").(*entities.User)
	if !ok || user == nil {
		return nil, fmt.Errorf("authentication required")
	}

	// Buscar dados completos do usuário
	fullUser, err := r.UserRepo.GetByID(ctx, user.ID)
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	// Remove password from response
	fullUser.Password = ""
	return fullUser, nil
}

// Towers is the resolver for the towers field.
func (r *queryResolver) Towers(ctx context.Context) ([]*entities.Tower, error) {
	return r.TowerRepo.GetAll(ctx)
}

// Tower is the resolver for the tower field.
func (r *queryResolver) Tower(ctx context.Context, id string) (*entities.Tower, error) {
	return r.TowerRepo.GetByID(ctx, id)
}

// Floors is the resolver for the floors field.
func (r *queryResolver) Floors(ctx context.Context, towerID *string) ([]*entities.Floor, error) {
	if towerID != nil {
		return r.FloorRepo.GetByTowerID(ctx, *towerID)
	}
	return []*entities.Floor{}, nil
}

// Floor is the resolver for the floor field.
func (r *queryResolver) Floor(ctx context.Context, id string) (*entities.Floor, error) {
	return r.FloorRepo.GetByID(ctx, id)
}

// Apartments is the resolver for the apartments field.
func (r *queryResolver) Apartments(ctx context.Context, floorID *string) ([]*entities.Apartment, error) {
	if floorID != nil {
		return r.ApartmentRepo.GetByFloorID(ctx, *floorID)
	}
	// Get all available apartments as default
	return r.ApartmentRepo.GetByStatus(ctx, entities.ApartmentStatusAvailable)
}

// Apartment is the resolver for the apartment field.
func (r *queryResolver) Apartment(ctx context.Context, id string) (*entities.Apartment, error) {
	return r.ApartmentRepo.GetByID(ctx, id)
}

// SearchApartments is the resolver for the searchApartments field.
func (r *queryResolver) SearchApartments(ctx context.Context, input model.ApartmentSearchInput) ([]*entities.Apartment, error) {
	criteria := &entities.ApartmentSearchCriteria{
		Number:        input.Number,
		Suites:        input.Suites,
		Bedrooms:      input.Bedrooms,
		ParkingSpots:  input.ParkingSpots,
		SolarPosition: input.SolarPosition,
		TowerID:       input.TowerID,
		FloorID:       input.FloorID,
		PriceMin:      input.PriceMin,
		PriceMax:      input.PriceMax,
		AreaMin:       input.AreaMin,
		AreaMax:       input.AreaMax,
		Available:     input.Available,
		Limit:         input.Limit,
		Offset:        input.Offset,
	}

	if input.Status != nil {
		status := entities.ApartmentStatus(*input.Status)
		criteria.Status = &status
	}

	return r.ApartmentRepo.Search(ctx, criteria)
}

// GalleryImages is the resolver for the galleryImages field.
func (r *queryResolver) GalleryImages(ctx context.Context, route *string) ([]*entities.GalleryImage, error) {
	if route != nil {
		return r.GalleryRepo.GetByRoute(ctx, *route)
	}
	return []*entities.GalleryImage{}, nil
}

// GalleryImage is the resolver for the galleryImage field.
func (r *queryResolver) GalleryImage(ctx context.Context, id string) (*entities.GalleryImage, error) {
	return r.GalleryRepo.GetByID(ctx, id)
}

// GalleryRoutes is the resolver for the galleryRoutes field.
func (r *queryResolver) GalleryRoutes(ctx context.Context) ([]string, error) {
	return []string{"home", "apartments", "amenities"}, nil
}

// ImagePins is the resolver for the imagePins field.
func (r *queryResolver) ImagePins(ctx context.Context, galleryImageID string) ([]*entities.ImagePin, error) {
	return r.ImagePinRepo.GetByGalleryImageID(ctx, galleryImageID)
}

// ImagePin is the resolver for the imagePin field.
func (r *queryResolver) ImagePin(ctx context.Context, id string) (*entities.ImagePin, error) {
	return r.ImagePinRepo.GetByID(ctx, id)
}

// AppConfig is the resolver for the appConfig field.
func (r *queryResolver) AppConfig(ctx context.Context) (*entities.AppConfig, error) {
	return r.AppConfigRepo.Get(ctx)
}

// GenerateSignedUploadURL is the resolver for the generateSignedUploadUrl field.
func (r *queryResolver) GenerateSignedUploadURL(ctx context.Context, fileName string, contentType string, folder string) (*entities.SignedUploadURL, error) {
	return r.StorageService.GenerateSignedUploadURL(ctx, fileName, contentType, folder)
}

// GenerateBulkDownload is the resolver for the generateBulkDownload field.
func (r *queryResolver) GenerateBulkDownload(ctx context.Context, towerID *string) (*entities.BulkDownload, error) {
	if towerID == nil {
		return nil, fmt.Errorf("tower ID is required")
	}

	result, err := r.BulkDownloadService.GenerateTowerDownload(ctx, *towerID)
	if err != nil {
		return nil, err
	}

	return &entities.BulkDownload{
		DownloadURL: result.DownloadURL,
		FileName:    result.FileName,
		FileSize:    result.FileSize,
		ExpiresIn:   result.ExpiresIn,
		CreatedAt:   result.CreatedAt,
	}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*entities.User, error) {
	users, err := r.UserRepo.List(ctx, 100, 0) // Limit 100 users for now
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	// Remove passwords from response
	for _, user := range users {
		user.Password = ""
	}

	return users, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*entities.User, error) {
	user, err := r.UserRepo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	// Remove password from response
	user.Password = ""
	return user, nil
}

// GetSignedDownloadUrls is the resolver for the getSignedDownloadUrls field.
func (r *queryResolver) GetSignedDownloadUrls(ctx context.Context, input model.SignedDownloadUrlsInput) (*model.SignedDownloadUrlsResponse, error) {
	expirationMinutes := 60 // padrão 1 hora
	if input.ExpirationMinutes != nil {
		expirationMinutes = *input.ExpirationMinutes
	}
	
	serviceInput := &entities.SignedDownloadURLsInput{
		RouteID:           input.RouteID,
		FileIDs:           input.FileIds,
		ExpirationMinutes: expirationMinutes,
	}
	
	response, err := r.FileService.GetSignedDownloadURLs(ctx, serviceInput)
	if err != nil {
		return nil, err
	}
	
	urls := make([]*model.FileDownloadURL, len(response.URLs))
	for i, url := range response.URLs {
		urls[i] = &model.FileDownloadURL{
			FileID:      url.FileID,
			DownloadURL: url.DownloadURL,
			ExpiresAt:   url.ExpiresAt.Format("2006-01-02T15:04:05Z07:00"),
		}
	}
	
	return &model.SignedDownloadUrlsResponse{
		Urls: urls,
	}, nil
}

// GetSyncStatus is the resolver for the getSyncStatus field.
func (r *queryResolver) GetSyncStatus(ctx context.Context, syncID string) (*model.SyncStatusResponse, error) {
	return &model.SyncStatusResponse{
		Status:      model.SyncStatusCompleted,
		Progress:    &[]float64{1.0}[0],
		ZipURL:      &[]string{fmt.Sprintf("https://storage.example.com/syncs/%s.zip", syncID)}[0],
		CompletedAt: &[]string{time.Now().Format("2006-01-02T15:04:05Z07:00")}[0],
	}, nil
}

// GetRouteBusinessData is the resolver for the getRouteBusinessData field.
func (r *queryResolver) GetRouteBusinessData(ctx context.Context, routeID string) (*model.RouteBusinessDataResponse, error) {
	return &model.RouteBusinessDataResponse{
		Route: &model.RouteData{
			ID:           routeID,
			Name:         "Rota de Exemplo",
			Description:  &[]string{"Descrição da rota"}[0],
			LastModified: time.Now().Format("2006-01-02T15:04:05Z07:00"),
		},
		Floors:      []*model.FloorData{},
		Apartments:  []*model.ApartmentData{},
		Carousels:   []*model.CarouselData{},
	}, nil
}

// GetCacheConfiguration is the resolver for the getCacheConfiguration field.
func (r *queryResolver) GetCacheConfiguration(ctx context.Context) (*model.CacheConfiguration, error) {
	return &model.CacheConfiguration{
		MaxFileSize:         10485760, // 10MB
		AllowedTypes:        []string{"image", "video", "document", "floorplan"},
		CompressionEnabled:  true,
		CacheExpiration:     3600, // 1 hora
	}, nil
}

// GetMenus is the resolver for the getMenus field.
func (r *queryResolver) GetMenus(ctx context.Context, routeID string) (*model.MenusResponse, error) {
	return &model.MenusResponse{
		Menus: []*model.Menu{
			{
				ID:     "menu_1",
				Title:  "Menu Principal",
				Type:   model.MenuTypeMain,
				Route:  "/main",
				Order:  1,
				IsActive: true,
			},
		},
	}, nil
}

// GetImageCarousel is the resolver for the getImageCarousel field.
func (r *queryResolver) GetImageCarousel(ctx context.Context, carouselID string) (*model.ImageCarouselResponse, error) {
	return &model.ImageCarouselResponse{
		Carousel: &model.ImageCarousel{
			ID:    carouselID,
			Title: "Carousel de Exemplo",
			Route: "/carousel",
			Items: []*model.CarouselItem{},
			CreatedAt: time.Now().AddDate(0, -1, 0).Format("2006-01-02T15:04:05Z07:00"),
			UpdatedAt: time.Now().Format("2006-01-02T15:04:05Z07:00"),
		},
	}, nil
}

// GetFloorPlan is the resolver for the getFloorPlan field.
func (r *queryResolver) GetFloorPlan(ctx context.Context, floorPlanID string) (*model.FloorPlanResponse, error) {
	return &model.FloorPlanResponse{
		FloorPlan: &model.FloorPlan{
			ID:    floorPlanID,
			Title: "Planta Exemplo",
			Route: "/floorplan",
			Floors: []*model.FloorPlanFloor{},
			Markers: []*model.FloorMarker{},
		},
	}, nil
}

// GetApartmentAvailability is the resolver for the getApartmentAvailability field.
func (r *queryResolver) GetApartmentAvailability(ctx context.Context, floorPlanID string) (*model.ApartmentAvailabilityResponse, error) {
	return &model.ApartmentAvailabilityResponse{
		Summary: &model.AvailabilitySummary{
			Total:     50,
			Available: 25,
			Sold:      20,
			Reserved:  3,
			Blocked:   2,
		},
		Apartments: []*model.FloorApartment{},
	}, nil
}

// GetPinMap is the resolver for the getPinMap field.
func (r *queryResolver) GetPinMap(ctx context.Context, pinMapID string) (*model.PinMapResponse, error) {
	return &model.PinMapResponse{
		PinMap: &model.PinMap{
			ID:    pinMapID,
			Title: "Mapa de Pins Exemplo",
			Route: "/pinmap",
			Pins:  []*model.Pin{},
		},
	}, nil
}

// SearchPins is the resolver for the searchPins field.
func (r *queryResolver) SearchPins(ctx context.Context, input model.SearchPinsInput) (*model.SearchPinsResponse, error) {
	return &model.SearchPinsResponse{
		Pins: []*model.SearchPinResult{},
	}, nil
}

// Fields is the resolver for the fields field.
func (r *signedUploadUrlResolver) Fields(ctx context.Context, obj *entities.SignedUploadURL) (*string, error) {
	return nil, nil // Opcional
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// SignedUploadUrl returns generated.SignedUploadUrlResolver implementation.
func (r *Resolver) SignedUploadUrl() generated.SignedUploadUrlResolver {
	return &signedUploadUrlResolver{r}
}

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type signedUploadUrlResolver struct{ *Resolver }

// convertFileContext converte o modelo GraphQL para a entidade
func convertFileContext(ctx *model.FileContextInput) *entities.FileContextInput {
	if ctx == nil {
		return nil
	}
	
	var coords *entities.CoordinatesInput
	if ctx.Coordinates != nil {
		coords = &entities.CoordinatesInput{
			Latitude:  ctx.Coordinates.Latitude,
			Longitude: ctx.Coordinates.Longitude,
		}
	}
	
	return &entities.FileContextInput{
		PinID:       ctx.PinID,
		Coordinates: coords,
		FloorID:     ctx.FloorID,
		FloorNumber: ctx.FloorNumber,
		IsReference: ctx.IsReference,
		CarouselID:  ctx.CarouselID,
		Order:       ctx.Order,
		Title:       ctx.Title,
		Description: ctx.Description,
		Tags:        ctx.Tags,
	}
}
